---
layout: default
title: 객체지향?..OOP와 SOLID
parent: 자바
nav_order: 0
permalink: /java/004
---

## 객체지향...OOP와 SOLID
{: .fs-9 }
OOP(Object-Oriented Programming) 객체단위로 프로그래밍에 필요한 데이터를 추상화시켜 어떠한 상태와 행위를 가진 객체를 만들어 객체들간 상호작용으로 프로그래밍하는 방법이라고 짧게 설명할수 있다.
즉, 붕어빵을 산다라는 프로그래밍을 만들때 나 라는 객체와 붕어빵이라는 객체 돈이라는 객체들이 서로 상호 작용을 통해 프로그래밍 되는 방식 이라고 할수 있다.

## 객체 지향의 장단점
> 장점
> 1. 코드의 재사용성이 높다
> 2. 객체 별로 나누기 때문에 결합도를 떨어 뜨릴수 있다

> 단점
> 1. 객체별로 나누어 코딩하므로 때에 따라 용량이 커질수 있다.


## 객체 지향의 특징

### 1. 캡슐화
- 하나의 객체를 해당 객체를 나눈 이유에 따라 변수나 메소드를 묶어서 처리한다. 나눈 이유가 "붕어빵" 이라는 객체라면 안에 붕어빵 레시피가 있어야 한다는 의미와 같다.
- 정보은닉의 용이하다. public , private, protect 를 통해 불필요한 정보나 객체외에는 건들수 없는 정보를 처리하기 용이하다.

### 2. 추상화
- 공통적인 부분을 묶어서 이후 개발시 큰 청사진을 알려줄수 있다 예를 들어 동물은 모두 움직인다 -> 사람은 두발로 움직인다 이러하게 프로그래밍이 가능하다.

### 3. 다형성
- 상속을 통한 확장과 변경, 같은 모습을 가지고 있어도 다른 결과를 가져올때를 말할수 있다. 이는 여름에 물을 뿌리면 시원하지만 겨울에 뿌리면 얼음이 되는것과 같다.
- 상속을 통해 좀더 재사용이 가능한 코드를 가져올수 있도 큰 청사진을 통해 작업의 통일성을 가져올수있다이로 인해 응집도를 높일수 있다.

### 3-1. Overrriding vs Overloading
- Overrriding : 부모 클래스에서 상속 받은 메소드를 다시 정의 하여 사용한다. 해당 메소드의 행위를 보다 세밀하거나 예외적을 처리하는 것이다. 
- Overloading : 부모 클래스에서 상속 받은 메소드를 확장 하여 사용한다. 매개변수의 갯수나 타입을 다르게 하여 추상화된 행동을 취하는 것이다.

```js
public class parents{
  public String name;
  public int age;
  
  public void do_go(){
    System.out.println("걷는다");
  }
}
public class child extends parents{
  
  //Overrriding
  public void do_go(){
    System.out.println("뛴다");
  }
  //Overloading
  public void do_go(String vehicle){
    System.out.println(vehicle+" 탄다");
  }
}


```

## SOLID
객체지향 프로그래밍이라면 지켜야하는 3가지 기본원칙을 말하는 단어이다. 이 원칙으로 개발한다면 객체 지향적으로 유지보수에 쉽고 확장하기 쉬운 프로그램이라고 할수있다.

### 1. S - SRP 단일 책임 원칙 (single responsibility principle)
- 작성된 클래스는 하나의 기능만 가지고 있어야 하며 그기능에 종속된 메소드와 데이터만 존재해야 한다는 의미이다. 즉, 붕어빵객체의 사람의 행동인 먹는다가 있으면 안된다.
- 코드의 가독성이 높아지며 하나의 객체의 메소드만 바꾸면 참조하는 모든 기능들이 바뀌므로 유지보수에 장점이 있다.

### 2. O - OCP 개방폐쇄의 원칙 (Open-Closed Principle)
- 기존 코드의 변경 없이 수정이 가능하도록 해야 한다.
- 상속의 개념과 비슷하다. 변할곳은 최대한 열어두고 고정적인것은 닫아 둬야한다.

### 3. L - LSP 리스코프 치환의 법칙 (Liskov Substitution Principle)
- 상속받은 클래스는 상속한 클래스에서 설계한 행위대로 행해져야 한다. 일관성이 이루어 져야 한다.
- 동물이라는 부모를 상속받은 사람은 움직일수 있어여 한다. 동물이라는 부모를 상속받은 소나무가 있다면 이는 움직일수 있어야 하나 움직일수 없으니 위배된다.

### 4. I - 인터페이스 분리 원칙 (Interface Segregation Principle)
- 하나의 클래스는 사용하지 않는 인터페이스는 구현하지 않는다. 자신이 사용하지 않는 기능에는 영향이 없어여 한다는 의미라 할수있다. 하나의 인터페이스보다 여러개의 구현체가 낮다.
- 사람이 동물이라는 인터페이스와 비행물이라는 인터페이스를 사용할시 비행물의 난다라는 기능이 있어야하지만 이는 구현할수 없다. 그러므로 위배된다고 할수 있다.

### 5. D - 의존 역전 원칙 (Dependency Inversion Principle)
- 의존 관계를 가진다면 변화하기 쉬운것이 아닌 변화하기 어려운것이여야 한다는 의미이다. 구채적으로 구현된 클래스보다 추상화 클래스로 관계를 맺자라는 것이다.
- 만약 본인이라는 클래스가 개발자라는 구체화된 클래스를 상속 받는다면 운전이라는 행위는 못하게 된다. 그렇다면 이는 상속적이라고 할수 없다.